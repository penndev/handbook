

## 对称加密

### base64

1字节（byte）可表示0-255共256个位（bit），目前（2023年）通用ASCII编码仅占用了128个标识，其中还有有33个标识是无法被显示器展示（控制，退格，删除等标识）。

部分文本协议如HTTP等需要传输原始字节流如byte(65)为了能展示这部分数据可以通过ASCII编码转换成字符`A`来标识这个字节。但是如果字节变更为byte(165)则不能通过ASCII进行显示了。因为ASCII没有165对应的编码。

为了应对上面遇到的难题则可以通过64位可见字符（ASCII可见字符为128-33）对照编码再次对字节进行编码。这样就可以通过显示器可以展示出来的数据来表示原始字节流了。但是这样会导致数据变大，因为原本的字节大小是 256 通过 64 位字符编码256大小的数据显而易见是会导致数据变大的。

例：对字符 `AAA` 进行编码（对应的二进制表示通过ASCII查找）
```
   A    |    A   |   A
01000001|01000001|01000001
010000|010100|000101|000001
  Q   |  U   | F    |  B
```
根据rfc对应的base64编码表（rfc4648）下面的四个标识为 `QUFB` 由此可见数据经过base64编码则数据最少(因为会有补位的情况)会增加原始数据的 1/3 左右。

我们可以通过更换或者打乱 base64 的编码表来实现数据的独家加解密。这样有存在被破译出自己的base编码表的可能性 **（有空再来探讨破译非标准base64编码表的算力难度）**



## 非对称加密

### AES

#### openssl 加密文件与解密文件
- `-e` 加密
- `-d` 解密
- `-K` 加密密钥16 byte的HEX 例:`000102030405060708090a0b0c0d0e0f`
- `-iv` 偏移量16 byte的HEX 例:`000102030405060708090a0b0c0d0e0f`

```bash
# 加密文件
openssl enc -aes-128-cbc -e -K 00000000000000000000000000000000 -iv 00000000000000000000000000000000 -in infile -out outfile
# 解密文件
openssl enc -aes-128-cbc -d -K 00000000000000000000000000000000 -iv 00000000000000000000000000000000 -in infile -out outfile
```
