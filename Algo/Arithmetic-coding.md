
# 算数编码

算数编码是一种熵编码


## 编码示例

- 开始编码原始区间
    ```
    示例字符：AABABCABAB
    ----------
    字符 = 概率数区间
    A   = 0.5 [0, 0.5]
    B   = 0.4 [0.5 0.9]
    C   = 0.1 [0.9, 1]
    ```
1. 第一个字母 A 根据 A 区间开始编码 A:[0-0.5]
    ```
    A   =   [0, 0.25] 
    B   =   [0.25, 0.45]
    C   =   [0.45, 0.5]
    ```

2. 第二个字母 A 根据 A 区间开始编码 A:[0-0.25]
    ```
    A [0, 0.125]
    B:[0.125, 0.225]
    C:[0.225, 0.25]
    ```

3. 第三个字母 B 根据 B 区间开始编码 B:[0.125-0.225]
    ```
    A:[0.125, 0.175]
    B:[0.175, 0.215]
    C:[0.215, 0.225]
    ```

4. 所有字母编码后汇总
    ```
    当前字符   =   当前目标区间
    A       =   [0, 0.5]
    A       =   [0, 0.25]
    B       =   [0.125, 0.225]
    A       =   [0.125, 0.175]
    B       =   [0.15, 0.17]
    C       =   [0.168, 0.17]
    A       =   [0.168, 0.169]
    B       =   [0.1685, 0.1689]
    A       =   [0.1685, 0.1687]
    B       =   [0.1686, 0.16868]
    ```
- 至此 最后的区间`[0.1686, 0.16868]`已经是最终的编码结果

## 解码示例

1. [0.1686, 0.16868]在原始区间[0, 0.5]
第一个字母为 A
2. [0.1686, 0.16868]在原始区间[0, 0.25] 第二个字母仍然为A
3. [0.1686, 0.16868]在原始区间[0.125, 0.225] 第二个字母为B
4. [0.1686, 0.16868]在原始区间[0.125, 0.175] 第二个字母为A

....依次处理


**解码方必须知道 1.概率分布  2. 流的长度; 不知道1就无法划分区间；不知道2就无法在正确的位置停下来，很有可能一直分下去结果解出来的码超过明文长度**